#!/bin/bash

#------------------------------------------------------------------------------
# Definitions:
#------------------------------------------------------------------------------

# Instances:
NAME=$1
DOMAIN='demo.lan'
MAXVMS=4

# Servers:
DATA_SERVER='data01.demo.lan'
CONTAINER_SERVER='regi01.demo.lan'

# Filesystem locations:
IMGDIR="/root/coreos/${NAME}"
RUNDIR="${IMGDIR}/run"
CFGDIR="${IMGDIR}/conf"
LOGFILE='/var/log/coreup.log'
UDATA="${CFGDIR}/openstack/latest/user_data"

# Host resources:
HOST_CORES=`grep -c processor /proc/cpuinfo`
HOST_RAM=`free -m | awk '/Mem:/ {print $2}'`

#------------------------------------------------------------------------------
# Initializations:
#------------------------------------------------------------------------------

set -o pipefail
. /etc/init.d/functions

[ -d $IMGDIR ] || mkdir -p $IMGDIR
[ -d $RUNDIR ] || mkdir -p $RUNDIR
[ -d $CFGDIR ] || mkdir -p $CFGDIR
[ -d `dirname $UDATA` ] || mkdir -p `dirname $UDATA`

#------------------------------------------------------------------------------
# Common functions:
#------------------------------------------------------------------------------

function log {
  echo "$(date +'%b %d %T') [$NAME] $*" >> $LOGFILE
}

function is_alive {
  RETRIES=30; while [ $RETRIES -gt 0 ]; do
    (echo > /dev/tcp/${NAME}/22) &> /dev/null && return 0
    sleep 1; RETRIES=$((RETRIES - 1))
  done; return 1
}

#------------------------------------------------------------------------------
# Checks:
#------------------------------------------------------------------------------

# VM already running?
[ `pgrep -cf "qemu.*${NAME}"` -gt 0 ] && {
  action "${NAME} VM is already running" true
  exit 0
}

# Already running MAXVMS?
[ `pgrep -c qemu-system` -ge $MAXVMS ] && {
  action "Already running ${MAXVMS} VMs" false
  exit 1
}

#------------------------------------------------------------------------------
# Download and uncompress the CoreOS image:
#------------------------------------------------------------------------------

function download_coreos {
  wget --quiet http://${DATA_SERVER}/coreos/coreos_qemu.img.bz2 \
  -O - | bzcat > ${IMGDIR}/${NAME}.img
  [[ $? -ne 0 || ! -s ${IMGDIR}/${NAME}.img ]] && return 1 || return 0
}

[ -f ${IMGDIR}/${NAME}.img ] || {
  MSG='Downloading CoreOS image file...'; log "$MSG"
  (action "$MSG" download_coreos) && log 'OK! Download completed' || {
    log 'Ops! Unable to download or uncompress the image'; exit 1
  }
}

#------------------------------------------------------------------------------
# Resize the CoreOS image:
#------------------------------------------------------------------------------

function resize_image {
  qemu-img resize ${IMGDIR}/${NAME}.img +20G &> /dev/null && \
  return 0 || return 1
}

IMGSIZE=`qemu-img info --output=json ${IMGDIR}/${NAME}.img | jq '.["virtual-size"]'`
[ "$IMGSIZE" -lt "30000000000" ] && {
  MSG='Resizing CoreOS disk image...'; log "$MSG"
  (action "$MSG" resize_image) && log 'OK! Image has new size' || {
    log 'Ops! Unable to resize the image'; exit 1
  }
}

#------------------------------------------------------------------------------
# cloud-config:
#------------------------------------------------------------------------------

MSG='Generating cloud-config...'; log "$MSG"
KEYS=$(cat ~/.ssh/authorized_keys | sed 's/^env.*ssh/ - ssh/' | grep "^ -")

cat << EOF > ${UDATA}
#cloud-config

hostname: ${NAME}

ssh_authorized_keys:
${KEYS}

write_files:
  - path: /etc/systemd/system/docker.service.d/50-insecure-registry.conf
    content: |
      [Service]
      Environment=DOCKER_OPTS='--insecure-registry=${CONTAINER_SERVER}:5000'
  - path: /home/core/.bashrc
    permissions: 0644
    owner: root
    content: |
      [[ \$- != *i* ]] && return
      alias ls='ls -hF --color=auto --group-directories-first'
      alias l='ls -l'
      alias ll='ls -la'
      alias grep='grep --color=auto'
      alias dim='docker images'
      alias dps='docker ps'
      alias dip="docker inspect --format '{{ .NetworkSettings.IPAddress }}'"
      alias drm='docker rm \$(docker ps -qa)';

coreos:
  units:
    - name: etcd.service
      command: start
    - name: fleet.service
      command: start
    - name: 00-br0.netdev
      runtime: false
      content: |
        [NetDev]
        Name=br0
        Kind=bridge
    - name: 00-br1.netdev
      runtime: false
      content: |
        [NetDev]
        Name=br1
        Kind=bridge
    - name: 00-br2.netdev
      runtime: false
      content: |
        [NetDev]
        Name=br2
        Kind=bridge
    - name: 01-eth0.network
      runtime: false
      content: |
        [Match]
        Name=eth0

        [Network]
        Bridge=br0
    - name: 01-eth1.network
      runtime: false
      content: |
        [Match]
        Name=eth1

        [Network]
        Bridge=br1
    - name: 01-eth2.network
      runtime: false
      content: |
        [Match]
        Name=eth2

        [Network]
        Bridge=br2
    - name: 02-br0.network
      runtime: false
      content: |
        [Match]
        Name=br0

        [Network]
        DHCP=v4
    - name: 02-br1.network
      runtime: false
      content: |
        [Match]
        Name=br1

        [Network]
        DHCP=v4
    - name: 02-br2.network
      runtime: false
      content: |
        [Match]
        Name=br2

        [Network]
        DHCP=v4
  fleet:
    metadata: host=${NAME}
  etcd:
    name: ${NAME}
    addr: ${NAME}:4001
    peer-addr: ${NAME}:7001
EOF

echo $NAME | grep -q '01' || \
echo '    peers: core01:7001' >> ${UDATA}

action "$MSG" test $? -eq 0

#------------------------------------------------------------------------------
# Generate the host TAP interfaces:
#------------------------------------------------------------------------------

function generate_tap_interfaces {
  for i in 0 1 2; do
    ip l del ${NAME}_eth${i} &> /dev/null
    ip tuntap a d ${NAME}_eth${i} m tap || return 1
    brctl addif br${i} ${NAME}_eth${i} || return 1
    ip l s dev ${NAME}_eth${i} up || return 1
  done; return 0
}

MSG='Generating TAP interfaces...'; log "$MSG"
(action "$MSG" generate_tap_interfaces) && log 'OK! Interfaces are UP' || {
  log 'Ops! Unable to setup the interfaces'; exit 1
}

#------------------------------------------------------------------------------
# Start the virtual machine:
#------------------------------------------------------------------------------

function genmac {
  echo `hostname` $NAME $1 | md5sum | \
  hexdump -n3 -e'/3 "00:16:3e" 3/1 ":%02X"'
}

function create_vm {
  qemu-system-x86_64 \
  -enable-kvm \
  -name ${NAME}.${DOMAIN} \
  -smp sockets=$(($HOST_CORES / $MAXVMS)),cores=$(($HOST_CORES / $MAXVMS)),threads=1 \
  -m $(($HOST_RAM / $MAXVMS)) \
  -rtc base=utc \
  -machine accel=kvm,mem-merge=on \
  -boot order=c,reboot-timeout=60,strict=on \
  -cpu host \
  -nodefconfig \
  -device sga \
  -display none \
  -daemonize \
  \
  -netdev tap,ifname=${NAME}_eth0,id=hostnet0,vhost=on,script=no,downscript=no \
  -device virtio-net-pci,netdev=hostnet0,id=net0,romfile=,bus=pci.0,addr=0x3,mac=`genmac eth0` \
  \
  -netdev tap,ifname=${NAME}_eth1,id=hostnet1,vhost=on,script=no,downscript=no \
  -device virtio-net-pci,netdev=hostnet1,id=net1,romfile=,bus=pci.0,addr=0x4,mac=`genmac eth1` \
  \
  -netdev tap,ifname=${NAME}_eth2,id=hostnet2,vhost=on,script=no,downscript=no \
  -device virtio-net-pci,netdev=hostnet2,id=net2,romfile=,bus=pci.0,addr=0x5,mac=`genmac eth2` \
  \
  -drive if=none,file=${IMGDIR}/${NAME}.img,id=drive-virtio-disk0 \
  -device virtio-blk-pci,scsi=off,drive=drive-virtio-disk0,id=virtio-disk0 \
  \
  -fsdev local,id=conf,security_model=none,readonly,path=${CFGDIR} \
  -device virtio-9p-pci,fsdev=conf,mount_tag=config-2 \
  \
  -chardev socket,id=monitor,path=${RUNDIR}/monitor.sock,server,nowait \
  -mon chardev=monitor,id=monitor,mode=control \
  \
  -chardev socket,id=console,path=${RUNDIR}/console.sock,server,nowait \
  -device isa-serial,chardev=console,id=serial0 && return 0 || return 1
}

MSG='Starting the virtual machine...'; log "$MSG"
(action "$MSG" create_vm) && log 'OK! VM is running' || {
  log 'Ops! Unable to start VM'; exit 1
}

#------------------------------------------------------------------------------
# One time reboot:
#------------------------------------------------------------------------------

function powerdown_vm {
  (echo '{ "execute": "qmp_capabilities" }{ "execute": "system_powerdown" }' | \
  socat - unix-connect:${RUNDIR}/monitor.sock &> /dev/null) || return 1
  date > ${CFGDIR}/bootstrapped; sleep 3; return 0
}

[ ! -f ${CFGDIR}/bootstrapped ] && {

  MSG='Testing SSH port...'; log "$MSG"
  (action "$MSG" is_alive) && log 'OK! SSH port is listening' || {
    log 'Ops! SSH port failed to connect'; exit 1
  }

  MSG='Restarting after first boot...'; log "$MSG"
  (action "$MSG" powerdown_vm) && log 'OK! System is down' || {
    log 'Ops! Unable to powerdown'; exit 1
  }

  exec $0 $@
}

#------------------------------------------------------------------------------
# Test if port 22 is listening:
#------------------------------------------------------------------------------

MSG='Testing SSH port...'; log "$MSG"
(action "$MSG" is_alive) && log 'OK! SSH port is listening' || {
  log 'Ops! SSH port failed to connect'; exit 1
}
